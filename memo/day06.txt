주석은 항상 달기!!!
클래스는 여러 특징을 가진 애들을 나타내기 위해서 쓰고 그 여러 특징을 가진 애들 중 
동일한 특징을 가진 애들은 하나하나 클래스로 선언하지 말고 배열로 묶어서 쓴다.
즉, 회원1,회원2...회원1000은 배열에 넣어주고 회원이라는 것은 클래스로 선언한다.

메소드는 저장공간!!

--------------------------------------------------------------------------------------------------------------------------------------------
클래스 실습

상점 클래스
상품명
상품가격
재고

손님 클래스
이름
휴대폰번호
통장잔고
할인율

상점에서 상품 판매 시
손님의 할인율을 적용하여 판매

----------------------------------------------------------------------------------------------------------------------------------------
상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
	2. 여러 클래스 선언 시 필드가 겹칠 때 부모 클래스를 먼저 선언하고 공통 필드를 묶어서
	자식 클래스들에게 상속해준다.

상속 문법
	class A {
		A 필드
	}

	class B extends A{
		A, B 필드 (A를 B에서 쓸 수 있지만 B에서 A가 보이진 않는다.)
	}

A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

super() : 부모 생성자
	자식 클래스 타입의 객체로 부모 필드에 접근할 수 있다.
	하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당된다고 생각할 수 있다.
	사실 알고보니, 자식 생성자에는 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출 시 부모와 자식 필드 모두
	메모리에 할당된다. 이 때 부모 생성자를 호출하는 방법은 super()를 사용하는 것이다.
	만약, super()를 작성하지 않더라도 컴파일러가 자동으로 작성해준다.

다형성(polymorphism)
	1. 오버로딩 Day05 참고.
	2. 오버라이딩(재정의)
		부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의를 해야한다.
		이는 자식에서 부모 필드의 메소드와 동일한 이름으로 선언하는 것이다.
		부모 필드가 메모리에 먼저 할당되고 a라는 메소드가 먼저 올라간다고 하면,
		자식 필드가 메모리에 할당되면서 재정의한 a메소드가 새롭게 만들어지는 것이 아니라
		기존에 할당된 a메소드 저장공간에 새롭게 재정의한 자식 필드의 소스코드 주소가 들어가게 된다.
		따라서 자식 객체로 a메소드에 접근하면 자식 필드에서 재정의한 소스코드의 내용이 읽히게 된다	

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
접근 권한 제어자 (=접근자) 
	default : 다른 패키지에서 접근 불가 (작성을 안하면 자동으로 default로 생성된다.)
	public : 모든 곳에서 접근 가능, 해당 파일의 메인 클래스일 경우만 사용 가능. (메인 클래스가 아닌 다른 클래스는 public으로 선언할 수 없다.)
	protected : 다른 패키지에서 접근 불가, 자식은 가능. (자식은 어디에 있던지 protected로 선언된 것에 접근할 수 있다.)
	★★★★★★ private : 다른 클래스에서 접근 불가, 메소드로만 접근하자! -> 메소드(getter, setter 메소드) 만들어라 라는 말이다. => JSP에서 배울 수 있다.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
★★★★★★★★★★★※ 모든 자식은 부모타입이다. ★★★★★★★★★★★★★

Casting
	1. up casting : 자식 값을 부모타입으로 형변환 
	upcasting을 할 때 부모꺼를 자식이 재정의 하면 그 부분은 짤리지 않는다.
	 다만 아예 새롭게 만든 메소드가 짤린다는 것이다.(따라서 =@는 재정의한게 아닌 아예 새롭게 작성한 메소드 들)
	
	2. down casting : up casting된 객체를 자식타입으로 형변환
	※ 부모 값을 자식 타입으로 형변환 시 오류
	
Casting을 사용하는 이유
	모든 자식 값을 전달받기 위해서는 동일한 타입의 저장공간으로 받아야 한다.
	하지만 자식끼리는 서로 타입이 다르기 때문에 한 번에 전달받을 수가 없다.(자식 개수만큼 메소드를 만들어야 하는데 너무 비효율적이며 
	상속은 무한대로 할 수 있기 때문에 자식의 갯수를 알 수도 없다. 객체지향의 단점)
	이때 up casting을 사용하면, 모든 자식이 부모 타입이므로 하나의 저장공간에
	모든 자식을 받을 수 있게 된다.
	만약 up casting으로 자식 값을 전달받았다면, 자식에서 새롭게 구현한 기능들은 사용할 수 없기 때문에
	down casting을 통해서 복구하여 사용한다.	
	
instanceof(객체 간 타입 비교)
	a(객체) instanceof A(클래스)	 : 조건식. (a의 객체가 A클래스 타입이니? true false로 나온다.)	
	- a가 A타입이라면 true
	- a가 A타입이 아니라면 false
	