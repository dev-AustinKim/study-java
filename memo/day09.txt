예외 처리
	컴파일 시, 빌드 시, 런타임 시 오류가 발생하면
	이를 제어문으로 막을 수 있으나, 제어문으로도 막을 수 없는
	오류들을 직접 처리할 수 있어야 한다.

예외 처리 문법
	예외 발생 시 예외가 메모리에 올라간 것이다. 그 주소값을 어딘가에 넣지 않으면 강제종료 (catch가 그 주소값을 잡는 것이다.)
	Exception은 모든 오류의 부모이다. (upcasting)
	try {
		예외가 발생할 수 있는 문장
	} catch(예외이름 객체명) {
		예외 발생 시 실행할 문장
	} catch(예외이름 객체명) {
		예외 발생 시 실행할 문장
	} ... (catch는 여러 번 쓸 수 있다.)
	 catch(Exception e) { // 마지막에는 모든 애를 잡을 수 있는 부모타입인 Exception 타입을 넣어준다. -> 예상 가능한 오류들은 Exception 위에 써줘서 오류를 잡게 해주고 전혀 모르겠으면 마지막 catch에는 Exception을 써준다.
		예외 발생 시 실행할 문장
	} finally { // 오류가 발생을 하던 말던 항상 실행된다.
		예외 발생 여부에 상관없이 무조건 실행할 문장
		※ 외부 장치와 연결했을 경우 다시 닫을 때 주로 사용한다.(드라이버를 열었으면 닫아줘야함. 드라이버는 연결통로. 여기서는 DB와 자바간의 연결통로)
	}
	

예외 발생
	직접 예외를 발생시키기 위해서는 예외 던지기를 사용해야 하며, 이 때에는 생성자 호출 전 throw 키워드를 사용한다.
	예) throw new BadWordException();

사용자 정의 예외
	기본적으로 제공되는 예외가 아닌 특정 상황에서 직접 예외를 만들어야 한다면, Exception 혹은
	RuntimeException을 상속받아서 예외 클래스를 선언해야 한다.
	Exception은 컴파일러가 체크를 하기 때문에 예외 처리를 강제로 해야하고,
	RuntimeException은 컴파일러가 체크하지 않기 때문에 예외처리를 선택할 수 있다.	

내가 알아야 할 것 : 
	쓰자마자 오류가 발생한다면 try-catch문에 넣어주자.
	열기를 try문에서 하고 닫기를 finally에서 한다.
	오류를 직접 만들려면 Exception 클래스를 상속받아야 한다.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
API(Application Programming Interface)
	개발에 필요한 라이브러리들의 집합.
	선배 개발자들이 만들어 놓은 소스코드.
	
	- 내부 API 
		JDK 설치 시 제공해주는 기본 API
		docs.oracle.com/javase
	
	- 외부 API	
		선배 개발자들이 개발한 패키지 및 클래스들을 의미한다.	
		보통 JAR파일로 배포하며 자바 프로젝트의 build path에 추가하여 사용할 수 있다.
		
프로젝트 클릭 -> buildpath -> configure build path -> libraries 가서 ClassPath누르고 Add external jar 눌러서 파일 받아오고 apply 
-> 옆에 order and export 가서 All select해서 apply 해주고 -> apply and close 누르기.

- 위와 동일.
JAR 파일로 배포하기
   배포할 클래스 또는 패키지 우클릭
   > Export > JAVA/JAR file 선택 > Next
   > destination을 원하는 경로로 선택
   > Export Java source files... 체크
   > Finish

JAR 파일을 프로젝트에 추가하기
   배포된 JAR파일을 다운 받기
   > 프로젝트 우클릭 > Build Path > Configure Build Path
   > Libraries 탭 클릭 > ClassPath(안되면 ModulePath) 클릭 > Add External JARs
   > 저장된 경로의 .jar파일을 더블 클릭으로 추가 > Apply 클릭
   > Orders and Exports 탭 클릭
   > Select All 클릭 > Apply and Close

메소드가 return을 만나면 바로 종료.

 ----------------------------------------------------------------------------------------------------------------------------------------------------------
Object 클래스 (3가지 전부 다 재정의해서 우리 입맛대로 바꾼 다음에 사용하자.)
	1. toString()
		항상 객체명을 출력할 때에는 toString()을 붙여서 출력해준다.
		따라서 객체명만 출력메소드에 전달하더라도 toString() 문자열 값이 출력된다.
		기본적으로 Object에서는 소속과 필드 주소를 문자열로 리턴해주지만,
		실사용에서는 불필요한 정보이기 때문에, 재정의한 뒤 필드의 정보를 확인하도록 구현한다.
		실무에서는 클래스 선언 시 각 필드의 초기화 여부를 확인하기 위해 toString()을 재정의하여 사용한다.
		클래스 선언 하자마자 재정의 해야함.(마치 기본생성자처럼.)
		
	2. equals() : "=="은 주소비교. Object에 선언된 equals도 주소비교.
		주소값 비교(==)
		String 클래스에서 equals()를 값 비교로 재정의하여 사용하기 때문에
		문자열 비교는 무조건 equals()로 비교한다.
			

	3.  hashCode() (= 변화하는 주소 값을 자바만의 방식으로 약간 변형시킨 것.)
		JVM에서 관리하는 중복없는 값. 실제 메모리에 할당되는 주소와는 다르다.
		String 클래스에서는 필드의 해시코드 값이 아닌 문자열 상수값의 해시코드 값을
		리턴하도록 재정의하였다.
		※ 컬렉션 프레임워크 챕터에서 재정의 목적을 이해하도록 한다.

native는 C언어의 것을 자바로 가져오려고 사용하는 것이다.

해당 필드에 메모리에 올라가야 객체로 쓴다? 질문

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Wrapper Class : 기본 자료형들의 클래스 타입
	클래스타입 객체 = new 클래스타입(일반타입의 값); // boxing, 권장하지 않는다(Deprecated).
	클래스타입 객체 = 클래스타입.valueOf(일반타입의 값); // boxing. 보통 위에 것이 아닌 밑에 것을 쓴다.
	일반타입 변수 = 객체.000Value(); // unboxing

	JDK4버전 이상부터는 auto를 지원한다.

	클래스타입 객체 = 일반타입의 값; // auto boxing
	일반타입 변수  = 객체; // auto unboxing
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
컬렉션 프레임워크
	
	
	
	


	
	
	
	
			